<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>西山ダディダディマルコフワッショイピーポーピーポー</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            background: #f0f0f0;
            cursor: pointer;
        }

        .node {
            fill: lightblue;
            stroke: #333;
            stroke-width: 2px;
        }

        .active {
            fill: orange !important;
        }

        .label {
            font: 14px sans-serif;
            text-anchor: middle;
            pointer-events: none;
        }

        .edge {
            stroke: #888;
            stroke-width: 2px;
            fill: none;
            marker-end: url(#arrow);
        }

        .weight-label {
            font: 12px sans-serif;
            fill: #555;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="overlay">クリックして再生をスタート</div>
    <svg id="svgCanvas">
        <defs>
            <marker id="arrow" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto"
                markerUnits="strokeWidth">
                <path d="M0,0 L8,4 L0,8 Z" fill="#888" />
            </marker>
        </defs>
    </svg>
    <audio id="audioPlayer"></audio>

    <script>
        const nodes = [
            { id: '西', x: 200, y: 100, audio: 'audio/西.mp3' },
            { id: '山', x: 400, y: 80, audio: 'audio/山.mp3' },
            { id: 'ﾀﾞﾃﾞｨ', x: 600, y: 120, audio: 'audio/ダディ2.mp3' },
            { id: 'ﾄﾞｽｺｲ', x: 700, y: 300, audio: 'audio/ドスコイ.mp3' },
            { id: 'ﾜｯｼｮｲ', x: 600, y: 480, audio: 'audio/ワッショイ.mp3' },
            { id: 'ﾋﾟｰﾎﾟｰ', x: 400, y: 520, audio: 'audio/ピーポー.mp3' },
            { id: 'YYYY', x: 200, y: 400, audio: 'audio/nobasi.mp3' }
        ];

        const transitions = {
            西: [{ to: '山', w: 1.0 }],
            山: [{ to: 'ﾀﾞﾃﾞｨ', w: 1.0 }],
            ﾀﾞﾃﾞｨ: [{ to: 'ﾄﾞｽｺｲ', w: 0.25 }, { to: 'YYYY', w: 0.25 }, { to: 'ﾀﾞﾃﾞｨ', w: 0.5 }],
            ﾄﾞｽｺｲ: [{ to: 'ﾜｯｼｮｲ', w: 1.0 }],
            ﾜｯｼｮｲ: [{ to: 'ﾋﾟｰﾎﾟｰ', w: 1.0 }],
            ﾋﾟｰﾎﾟｰ: [{ to: 'ﾋﾟｰﾎﾟｰ', w: 0.5 }, { to: '西', w: 0.5 }],
            YYYY: [{ to: '西', w: 1.0 }]
        };

        const svg = document.getElementById('svgCanvas');
        const ns = 'http://www.w3.org/2000/svg';
        let current = nodes[0].id;

        function drawGraph() {
            // エッジ描画
            Object.entries(transitions).forEach(([from, tos]) => {
                const src = nodes.find(n => n.id === from);
                tos.forEach(({ to, w }) => {
                    const dst = nodes.find(n => n.id === to);
                    if (from === to) {
                        // 自己ループ: 円弧で表現
                        const path = document.createElementNS(ns, 'path');
                        const r = 30;
                        const startX = src.x + r;
                        const startY = src.y;
                        // ループ半径
                        const loopR = 20;
                        const d = `M ${startX} ${startY} ` +
                            `A ${loopR} ${loopR} 0 1 1 ${startX - 0.1} ${startY}`;
                        path.setAttribute('d', d);
                        path.setAttribute('class', 'edge');
                        svg.appendChild(path);
                        // 重みラベル
                        const text = document.createElementNS(ns, 'text');
                        text.setAttribute('x', src.x + r + loopR);
                        text.setAttribute('y', src.y - loopR);
                        text.setAttribute('class', 'weight-label');
                        text.textContent = w.toFixed(2);
                        svg.appendChild(text);
                    } else {
                        // 通常エッジ
                        const line = document.createElementNS(ns, 'line');
                        // ノード円の端に線を合わせる
                        const angle = Math.atan2(dst.y - src.y, dst.x - src.x);
                        const offset = 25;
                        const x1 = src.x + Math.cos(angle) * offset;
                        const y1 = src.y + Math.sin(angle) * offset;
                        const x2 = dst.x - Math.cos(angle) * offset;
                        const y2 = dst.y - Math.sin(angle) * offset;
                        line.setAttribute('x1', x1);
                        line.setAttribute('y1', y1);
                        line.setAttribute('x2', x2);
                        line.setAttribute('y2', y2);
                        line.setAttribute('class', 'edge');
                        svg.appendChild(line);
                        // 重みラベル
                        const mx = (x1 + x2) / 2;
                        const my = (y1 + y2) / 2;
                        const text = document.createElementNS(ns, 'text');
                        text.setAttribute('x', mx);
                        text.setAttribute('y', my - 5);
                        text.setAttribute('class', 'weight-label');
                        text.textContent = w.toFixed(2);
                        svg.appendChild(text);
                    }
                });
            });
            // ノード描画
            nodes.forEach(n => {
                const c = document.createElementNS(ns, 'circle');
                c.setAttribute('cx', n.x);
                c.setAttribute('cy', n.y);
                c.setAttribute('r', 25);
                c.setAttribute('class', 'node');
                c.setAttribute('id', `node-${n.id}`);
                svg.appendChild(c);
                const t = document.createElementNS(ns, 'text');
                t.setAttribute('x', n.x);
                t.setAttribute('y', n.y + 5);
                t.setAttribute('class', 'label');
                t.textContent = n.id;
                svg.appendChild(t);
            });
        }

        function highlight(id) {
            nodes.forEach(n => {
                document.getElementById(`node-${n.id}`)
                    .classList.toggle('active', n.id === id);
            });
        }

        function chooseNext(from) {
            const list = transitions[from];
            const sum = list.reduce((a, e) => a + e.w, 0);
            let r = Math.random() * sum, acc = 0;
            for (const { to, w } of list) {
                acc += w;
                if (r <= acc) return to;
            }
            return list[list.length - 1].to;
        }

        function playAudio(id) {
            const audioPlayer = document.getElementById('audioPlayer');
            return new Promise(res => {
                audioPlayer.src = nodes.find(n => n.id === id).audio;
                audioPlayer.play().catch(() => { });
                audioPlayer.onended = res;
                audioPlayer.onerror = res;
            });
        }

        async function step() {
            highlight(current);
            await playAudio(current);
            current = chooseNext(current);
            step();
        }

        drawGraph();
        svg.addEventListener('click', () => { step(); }, { once: true });
    </script>
</body>

</html>